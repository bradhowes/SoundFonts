// Copyright Â© 2020 Brad Howes. All rights reserved.

#pragma once

#include <algorithm>
#include <cmath>
#include <limits>

#include "Entity/Generator/Amount.hpp"
#include "Render/Utils.hpp"

namespace SF2 {
namespace Render {
namespace Envelope {

/**
 The stages that are supported by this envelope system.

 - idle -- the envelope is not active
 - delay -- initial delay before envelope attack phase
 - attack -- transition from 0.0 - 1.0
 - hold -- duration while at 1.0
 - decay -- transition from 1.0 to sustainLevel
 - sustain -- last stage while key is held down
 - release -- transition from sustainLevel to 0.0 after key is released
 */
enum struct Stage {
    idle = -1,
    delay = 0,
    attack,
    hold,
    decay,
    sustain,
    release
};

template <typename T>
struct Generator;

/**
 State for a single stage of an envelope.
 */
template <typename T>
struct StageState
{
    inline static constexpr T minimumCurvature = 0.000000001;
    inline static constexpr T maximumCurvature = 10.0;

    /**
     Generate a configuration that will emit a constant value for a fixed or indefinite time.
     */
    static StageState SetConstant(int sampleCount, T value) { return StageState(value, 1.0, 0.0, sampleCount); }

    /**
     Generate a configuration for the delay stage.
     */
    static StageState ConfigureDelay(int sampleCount) { return SetConstant(sampleCount, 0.0); }

    /**
     Generate a configuration for the attack stage.
     */
    static StageState ConfigureAttack(int sampleCount, T curvature) {
        curvature = clampCurvature(curvature);
        T alpha = calculateCoefficient(sampleCount, curvature);
        return StageState(0.0, alpha, (1.0 + curvature) * (1.0 - alpha), sampleCount);
    }

    /**
     Generate a configuration for the delay stage.
     */
    static StageState ConfigureHold(int sampleCount) { return SetConstant(sampleCount, 1.0); }

    /**
     Generate a configuration for the decay stage.
     */
    static StageState ConfigureDecay(int sampleCount, T curvature, T sustainLevel) {
        curvature = clampCurvature(curvature);
        T alpha = calculateCoefficient(sampleCount, curvature);
        return StageState(1.0, alpha, (sustainLevel - curvature) * (1.0 - alpha), sampleCount);
    }

    /**
     Generate a configuration for the sustain stage.
     */
    static StageState ConfigureSustain(T level) { return SetConstant(std::numeric_limits<uint16_t>::max(), level); }

    /**
     Generate a configuration for the release stage.
     */
    static StageState ConfigureRelease(int sampleCount, T curvature, T sustainLevel) {
        curvature = clampCurvature(curvature);
        T alpha = calculateCoefficient(sampleCount, curvature);
        return StageState(sustainLevel, alpha, (0.0 - curvature) * (1.0 - alpha), sampleCount);
    }

    /**
     Obtain the next value of a stage.

     @param last last value generated by a stage
     @returns new value
     */
    T next(T last) const { return std::max<T>(std::min<T>(last * alpha_ + beta_, 1.0), 0.0); }

private:

    StageState(T initial, T alpha, T beta, int durationInSamples) :
    initial_{initial}, alpha_{alpha}, beta_{beta}, durationInSamples_{durationInSamples} {}

    static T clampCurvature(T curvature) {
        return std::max(std::min(curvature, maximumCurvature), minimumCurvature);
    }

    static T calculateCoefficient(T sampleCount, T curvature) {
        curvature = clampCurvature(curvature);
        return (sampleCount <= 0.0) ? 0.0 : std::exp(-std::log((1.0 + curvature) / curvature) / sampleCount);
    }

    friend class Generator<T>;

    T initial_{0.0};
    T alpha_{0.0};
    T beta_{0.0};
    int durationInSamples_{0};
};

/**
 Collection of states for all of the stages in an envelope.
 */
template <typename T>
using StageStates = StageState<T>[static_cast<int>(Stage::release) + 1];

/**
 Generator of envelope values.
 */
template <typename T>
class Generator {
public:

    /**
     Construct a new generator.

     @param states the state for the envelope stages.
     */
    explicit Generator(const StageStates<T>& states) : states_{states} {}

    /// @returns the currently active stage.
    Stage stage() const { return stage_; }

    /// @returns true if the generator still has values to emit
    bool isActive() const { return stage_ != Stage::idle; }

    /// @returns true if the generator is active and has not yet reached the release state
    bool isGated() const { return isActive() && stage_ != Stage::release; }

    /// @returns the current envelope value.
    T value() const { return value_; }

    /**
     Set the status of a note playing. When true, the envelope begins proper. When set to false, the envelope will
     jump to the release stage.
     */
    void gate(bool noteOn) {
        if (noteOn) {
            value_ = 0.0;
            enterStage(Stage::delay);
        }
        else if (stage_ != Stage::idle) {
            enterStage(Stage::release);
        }
    }

    /**
     Calculate the next envelope value. This must be called on every sample for proper timing of the stages.

     @returns the new envelope value.
     */
    T process() {
        switch (stage_) {
            case Stage::delay: checkIfEndStage(Stage::attack); break;
            case Stage::hold: checkIfEndStage(Stage::decay); break;
            case Stage::attack: updateValue(); checkIfEndStage(Stage::hold); break;
            case Stage::decay: updateAndCompare(sustainLevel(), Stage::sustain); break;
            case Stage::release: updateAndCompare(0.0, Stage::idle); break;
            default: break;
        }

        return value_;
    }

private:

    void updateAndCompare(T floor, Stage next) {
        updateValue();
        if (value_ < floor)
            enterStage(next);
        else
            checkIfEndStage(next);
    }

    const StageState<T>& active() const { return stage(stage_); }

    const StageState<T>& stage(Stage stage) const { return states_[static_cast<int>(stage)]; }

    T sustainLevel() const { return stage(Stage::sustain).initial_; }

    void updateValue() { value_ = active().next(value_); }

    void checkIfEndStage(Stage next) { if (--counter_ == 0) enterStage(next); }

    int activeDurationInSamples() const { return active().durationInSamples_; }

    void enterStage(Stage next) {
        stage_ = next;
        switch (stage_) {
            case Stage::delay:
                if (activeDurationInSamples()) break;
                stage_ = Stage::attack;

            case Stage::attack:
                if (activeDurationInSamples()) break;
                stage_ = Stage::hold;

            case Stage::hold:
                value_ = 1.0;
                if (activeDurationInSamples()) break;
                stage_ = Stage::decay;

            case Stage::decay:
                if (activeDurationInSamples()) break;
                stage_ = Stage::sustain;

            case Stage::sustain:
                value_ = active().initial_;
                break;

            case Stage::release:
                if (activeDurationInSamples()) break;
                stage_ = Stage::idle;
                value_ = 0.0;

            case Stage::idle: return;
        }

        counter_ = activeDurationInSamples();
    }

    const StageStates<T>& states_;
    Stage stage_{Stage::idle};
    int counter_{0};
    T value_{0.0};
};

/**
 Configuration of the SF2 volume/filter envelope. It contains 6 stages:

 - Delay -- number of seconds to delay the beginning of the attack stage
 - Attack -- number of seconds to ramp up from 0.0 to 1.0. Also supports non-linear curvature.
 - Hold -- number of seconds to hold the envelope at 1.0 before entering the decay stage.
 - Decay -- number of seconds to lower the envelope from 1.0 to the sustain level
 - Sustain -- a stage that lasts as long as a note is held down
 - Release -- number of seconds to go from sustain level to 0.0

 The envelope will remain in the idle state until `gate(true)` is invoked. It will remain in the sustain stage until
 `gate(false)` is invoked at which point it will enter the `release` stage. Although the stages above are listed in the
 order in which they are performed, any stage will transition to the `release` stage upon a `gate(false)`
 call.

 The more traditional ADSR (attack, decay, sustain, release) envelope can be achieve by setting the delay and hold
 durations to zero (0.0).
 */
template <typename T>
struct Config {
    inline static constexpr T defaultCurvature = 0.01;

    /**
     Create new envelope definition with a bare configuration.

     @param sampleRate number of samples per second
     */
    explicit Config(T sampleRate) : Config(sampleRate, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) {}

    /**
     Create new envelope definition.

     @param sampleRate number of samples per second
     @param delay number of seconds before the attack stage begins
     @param attack duration of the attack stage where the envelope ramps from 0.0 to 1.0
     @param hold duration of the hold stage where the envelope remains at 1.0
     @param decay duration of the decay stage where the envelope ramps down from 1.0 to the sustain level
     @param sustain the sustain level (between 0.0 and 1.0)
     @param release duration of the release stage where the envelope ramps down from the sustain level to 0.0
     */
    Config(T sampleRate, T delay, T attack, T hold, T decay, T sustain, T release) :
    states_{
        StageState<T>::ConfigureDelay(samplesFor(sampleRate, delay)),
        StageState<T>::ConfigureAttack(samplesFor(sampleRate, attack), defaultCurvature),
        StageState<T>::ConfigureHold(samplesFor(sampleRate, hold)),
        StageState<T>::ConfigureDecay(samplesFor(sampleRate, decay), defaultCurvature, sustain),
        StageState<T>::ConfigureSustain(sustain),
        StageState<T>::ConfigureRelease(samplesFor(sampleRate, release), defaultCurvature, sustain)
    }
    {}

    /**
     Create a new envelope generator using the configured envelope settings.

     @returns new Generator using the current envelope configuration.
     */
    Generator<T> generator() const { return Generator(states_); }

private:
    static int samplesFor(T sampleRate, T duration) { return round(sampleRate * duration); }

    StageStates<T> states_;
};

} // namespace Envelope
} // namespace Render
} // namespace SF2
