// Copyright Â© 2020 Brad Howes. All rights reserved.

#pragma once

#include <algorithm>
#include <cassert>
#include <cmath>
#include <limits>
#include <vector>

#include "../Entity/Generator/Amount.hpp"
#include "Utils.hpp"

namespace SF2 {
namespace Render {

/**
 Representation of a traditional synthesizer volume/filter envelope. This one provides for 6 stages:

 - Delay -- number of seconds to delay the beginning of the attack stage
 - Attack -- number of seconds to ramp up from 0.0 to 1.0. Also supports non-linear curvature.
 - Hold -- number of seconds to hold the envelope at 1.0 before entering the decay stage.
 - Decay -- number of seconds to lower the envelope from 1.0 to the sustain level
 - Sustain -- a stage that lasts as long as a note is held down
 - Release -- number of seconds to go from sustain level to 0.0

 The envelope will remain in the idle state until `gate(true)` is invoked. It will remain in the sustain stage until
 `gate(false)` is invoked at which point it will enter the `release` stage. Although the stages above are listed in the
 order in which they are performed, any stage will transition to the `release` stage upon a `gate(false)`
 call.

 The more traditional ADSR (attack, decay, sustain, release) envelope can be achieve by setting the delay and hold
 durations to zero (0.0).
 */
class Envelope
{
public:

    /**
     The stages that are supported by this envelope system.
     */
    enum struct Stage {
        idle = -1,
        delay = 0,
        attack,
        hold,
        decay,
        sustain,
        release
    };

    /**
     Number of stages being used.
     */
    inline static constexpr int numStages = static_cast<int>(Stage::release) + 1;
    inline static constexpr Float defaultCurvature = 0.01;
    inline static constexpr Float minimumCurvature = 0.000000001;
    inline static constexpr Float maximumCurvature = 10.0;

    /**
     Configuration for a stage of the envelope. One configuration can be used to generate many envelopes.
     */
    struct StageConfiguration
    {
        /**
         Obtain the next value of a stage.

         @param last last value generated by a stage
         @returns new value
         */
        Float next(Float last) const { return std::max(std::min(last * alpha_ + beta_, 1.0), 0.0); }

        /**
         Generate a configuration for the attack stage.
         */
        void configureAttack(int sampleCount, Float curvature);

        /**
         Generate a configuration that will emit a constant value for a fixed or indefinite time.
         */
        void setConstant(int sampleCount, Float value);

        /**
         Generate a configuration for the decay stage.
         */
        void configureDecay(int sampleCount, Float curvature, Float sustainLevel);

        /**
         Generate a configuration for the sustain stage.
         */
        void configureSustain(Float level);

        /**
         Generate a configuration for the release stage.
         */
        void configureRelease(int sampleCount, Float curvature, Float sustainLevel);

        Float initial_{0.0};
        Float alpha_{0.0};
        Float beta_{0.0};
        int durationInSamples_{0};
    };

    using StageConfigs = StageConfiguration[numStages];

    /**
     Manager for an instance of an envelope. Uses a collection of StageConfigurations to set the parameters of the
     envelope.
     */
    struct Generator {

        /**
         Construct a new envelope generator.
         */
        explicit Generator(const StageConfigs& configs) : configs_{configs} {}

        /**
         Obtain the currently active stage.
         */
        Stage stage() const { return stage_; }

        /**
         Obtain the current envelope value.
         */
        Float value() const { return value_; }

        /**
         Set the status of a note playing. When true, the envelope begins proper. When set to false, the envelope will
         jump to the release stage.
         */
        void gate(bool noteOn);

        /**
         Calculate the next envelope value. This must be called on every sample for proper timing of the stages.
         */
        Float process();

    private:

        int stageAsIndex() const { return static_cast<int>(stage_); }

        const StageConfiguration& active() const { return stage(stage_); }

        const StageConfiguration& stage(Stage stage) const { return configs_[static_cast<int>(stage)]; }

        Float sustainLevel() const { return stage(Stage::sustain).initial_; }

        void updateValue() { value_ = active().next(value_); }

        void checkIfEndStage(Stage next) { if (--counter_ == 0) enterStage(next); }

        /**
         Enter the given stage, setting it up for processing. If the stage has no activity, move to the next one until
         there is one with non-zero samples or the end of the stage sequence is reached.
         */
        void enterStage(Stage next);

        const StageConfigs& configs_;
        Stage stage_{Stage::idle};
        int counter_{0};
        Float value_{0.0};
    };

    struct Config {

        Config(Float delay, Float attack, Float hold, Float decay, Float sustain, Float release)
        : delay_{delay}, attack_{attack}, hold_{hold}, decay_{decay}, sustain_{sustain}, release_{release} {}

        Float delay_{0.0};
        Float attack_{0.0};
        Float hold_{0.0};
        Float decay_{0.0};
        Float sustain_{1.0};
        Float release_{0.0};
    };

    explicit Envelope(Float sampleRate) : Envelope(sampleRate, Config(0.0, 0.0, 0.0, 0.0, 1.0, 0.0)) {}

    /**
     Create new envelope factory.
     */
    Envelope(Float sampleRate, const Config& config);

    /**
     Create a new envelope generator using the configured envelope settings.
     */
    Generator generator() const { return Generator(configs_); }

private:

    static int stageAsIndex(Stage stage) { return static_cast<int>(stage); }

    StageConfiguration& stage(Stage stage) { return configs_[static_cast<int>(stage)]; }

    static Float clampCurvature(Float curvature) {
        return std::max(std::min(curvature, maximumCurvature), minimumCurvature);
    }

    static Float calculateCoefficient(Float sampleCount, Float curvature) {
        curvature = clampCurvature(curvature);
        return (sampleCount <= 0.0) ? 0.0 : std::exp(-std::log((1.0 + curvature) / curvature) / sampleCount);
    }

    int samplesFor(Float duration) const { return round(sampleRate_ * duration); }

    StageConfiguration configs_[numStages];

    Float sampleRate_;
};

}
}
