// Copyright Â© 2020 Brad Howes. All rights reserved.

#pragma once

#include <algorithm>
#include <cmath>
#include <limits>

#include "Entity/Generator/Amount.hpp"
#include "Render/Utils.hpp"

namespace SF2 {
namespace Render {

/**
 Representation of the SF2 volume/filter envelope. It contains 6 stages:

 - Delay -- number of seconds to delay the beginning of the attack stage
 - Attack -- number of seconds to ramp up from 0.0 to 1.0. Also supports non-linear curvature.
 - Hold -- number of seconds to hold the envelope at 1.0 before entering the decay stage.
 - Decay -- number of seconds to lower the envelope from 1.0 to the sustain level
 - Sustain -- a stage that lasts as long as a note is held down
 - Release -- number of seconds to go from sustain level to 0.0

 The envelope will remain in the idle state until `gate(true)` is invoked. It will remain in the sustain stage until
 `gate(false)` is invoked at which point it will enter the `release` stage. Although the stages above are listed in the
 order in which they are performed, any stage will transition to the `release` stage upon a `gate(false)`
 call.

 The more traditional ADSR (attack, decay, sustain, release) envelope can be achieve by setting the delay and hold
 durations to zero (0.0).
 */
class Envelope
{
public:

    /**
     The stages that are supported by this envelope system.

     - idle -- the envelope is not active
     - delay -- initial delay before envelope attack phase
     - attack -- transition from 0.0 - 1.0
     - hold -- duration while at 1.0
     - decay -- transition from 1.0 to sustainLevel
     - sustain -- last stage while key is held down
     - release -- transition from sustainLevel to 0.0 after key is released
     */
    enum struct Stage {
        idle = -1,
        delay = 0,
        attack,
        hold,
        decay,
        sustain,
        release
    };

    inline static constexpr int numStages = static_cast<int>(Stage::release) + 1;
    inline static constexpr Float defaultCurvature = 0.01;
    inline static constexpr Float minimumCurvature = 0.000000001;
    inline static constexpr Float maximumCurvature = 10.0;

    /**
     Configuration for a stage of the envelope. One configuration can be used to generate many envelopes.
     */
    struct StageConfiguration
    {
        /**
         Obtain the next value of a stage.

         @param last last value generated by a stage
         @returns new value
         */
        Float next(Float last) const { return std::max(std::min(last * alpha_ + beta_, 1.0), 0.0); }

        /**
         Generate a configuration for the attack stage.
         */
        void configureAttack(int sampleCount, Float curvature) {
            curvature = clampCurvature(curvature);
            initial_ = 0.0;
            alpha_ = calculateCoefficient(sampleCount, curvature);
            beta_ = (1.0 + curvature) * (1.0 - alpha_);
            durationInSamples_ = sampleCount;
        }

        /**
         Generate a configuration that will emit a constant value for a fixed or indefinite time.
         */
        void setConstant(int sampleCount, Float value) {
            initial_ = value;
            alpha_ = 1.0;
            beta_ = 0.0;
            durationInSamples_ = sampleCount;
        }

        /**
         Generate a configuration for the decay stage.
         */
        void configureDecay(int sampleCount, Float curvature, Float sustainLevel) {
            curvature = clampCurvature(curvature);
            initial_ = 1.0;
            alpha_ = calculateCoefficient(sampleCount, curvature);
            beta_ = (sustainLevel - curvature) * (1.0 - alpha_);
            durationInSamples_ = sampleCount;
        }

        /**
         Generate a configuration for the sustain stage.
         */
        void configureSustain(Float level) {
            setConstant(std::numeric_limits<uint16_t>::max(), level);
        }

        /**
         Generate a configuration for the release stage.
         */
        void configureRelease(int sampleCount, Float curvature, Float sustainLevel) {
            initial_ = sustainLevel;
            alpha_ = calculateCoefficient(sampleCount, curvature);
            beta_ = (0.0 - curvature) * (1.0 - alpha_);
            durationInSamples_ = sampleCount;
        }

        Float initial_{0.0};
        Float alpha_{0.0};
        Float beta_{0.0};
        int durationInSamples_{0};
    };

    using StageConfigs = StageConfiguration[numStages];

    /**
     Generates values from an envelope over time.
     */
    struct Generator {

        /**
         Construct a new generator.

         @param configs the configuration for the envelope stages.
         */
        explicit Generator(const StageConfigs& configs) : configs_{configs} {}

        /// @returns the currently active stage.
        Stage stage() const { return stage_; }

        /// @returns true if the generator still has values to emit
        bool isActive() const { return stage_ != Stage::idle; }

        /// @returns the current envelope value.
        Float value() const { return value_; }

        /**
         Set the status of a note playing. When true, the envelope begins proper. When set to false, the envelope will
         jump to the release stage.
         */
        void gate(bool noteOn) {
            if (noteOn) {
                value_ = 0.0;
                enterStage(Stage::delay);
            }
            else if (stage_ != Stage::idle) {
                enterStage(Stage::release);
            }
        }

        /**
         Calculate the next envelope value. This must be called on every sample for proper timing of the stages.

         @returns the new envelope value.
         */
        Float process() {
            switch (stage_) {
                case Stage::delay: checkIfEndStage(Stage::attack); break;
                case Stage::hold: checkIfEndStage(Stage::decay); break;
                case Stage::attack: updateValue(); checkIfEndStage(Stage::hold); break;
                case Stage::decay: updateAndCompare(sustainLevel(), Stage::sustain); break;
                case Stage::release: updateAndCompare(0.0, Stage::idle); break;
                default: break;
            }

            return value_;
        }

    private:
        void updateAndCompare(Float floor, Stage next) {
            updateValue();
            if (value_ < floor)
                enterStage(next);
            else
                checkIfEndStage(next);
        }

        int stageAsIndex() const { return static_cast<int>(stage_); }

        const StageConfiguration& active() const { return stage(stage_); }

        const StageConfiguration& stage(Stage stage) const { return configs_[static_cast<int>(stage)]; }

        Float sustainLevel() const { return stage(Stage::sustain).initial_; }

        void updateValue() { value_ = active().next(value_); }

        void checkIfEndStage(Stage next) { if (--counter_ == 0) enterStage(next); }

        void enterStage(Stage next) {
            stage_ = next;
            switch (stage_) {
                case Stage::delay:
                    if (activeDurationInSamples()) break;
                    stage_ = Stage::attack;

                case Stage::attack:
                    if (activeDurationInSamples()) break;
                    stage_ = Stage::hold;

                case Stage::hold:
                    value_ = 1.0;
                    if (activeDurationInSamples()) break;
                    stage_ = Stage::decay;

                case Stage::decay:
                    if (activeDurationInSamples()) break;
                    stage_ = Stage::sustain;

                case Stage::sustain:
                    value_ = active().initial_;
                    break;

                case Stage::release:
                    if (activeDurationInSamples()) break;
                    stage_ = Stage::idle;
                    value_ = 0.0;

                case Stage::idle: return;
            }

            counter_ = activeDurationInSamples();
        }

        int activeDurationInSamples() const { return active().durationInSamples_; }

        const StageConfigs& configs_;
        Stage stage_{Stage::idle};
        int counter_{0};
        Float value_{0.0};
    };

    struct Config {

        Config(Float delay, Float attack, Float hold, Float decay, Float sustain, Float release)
        : delay_{delay}, attack_{attack}, hold_{hold}, decay_{decay}, sustain_{sustain}, release_{release} {}

        Float delay_{0.0};
        Float attack_{0.0};
        Float hold_{0.0};
        Float decay_{0.0};
        Float sustain_{1.0};
        Float release_{0.0};
    };

    /**
     Create new envelope definition with a bare configuration.

     @param sampleRate number of samples per second
     */
    explicit Envelope(Float sampleRate) : Envelope(sampleRate, Config(0.0, 0.0, 0.0, 0.0, 1.0, 0.0)) {}

    /**
     Create new envelope definition.

     @param sampleRate number of samples per second
     @param config configuration for the various stages of the envelope
     */
    Envelope(double sampleRate, const Config& config) : sampleRate_{sampleRate}
    {
        stage(Stage::delay).setConstant(samplesFor(config.delay_), 0.0);
        stage(Stage::attack).configureAttack(samplesFor(config.attack_), defaultCurvature);
        stage(Stage::hold).setConstant(samplesFor(config.hold_), 1.0);
        stage(Stage::decay).configureDecay(samplesFor(config.decay_), defaultCurvature, config.sustain_);
        stage(Stage::sustain).configureSustain(config.sustain_);
        stage(Stage::release).configureRelease(samplesFor(config.release_), defaultCurvature, config.sustain_);
    }

    /**
     Create a new envelope generator using the configured envelope settings.

     @returns new Generator using the current envelope configuration.
     */
    Generator generator() const { return Generator(configs_); }

private:

    static int stageAsIndex(Stage stage) { return static_cast<int>(stage); }

    StageConfiguration& stage(Stage stage) { return configs_[static_cast<int>(stage)]; }

    static Float clampCurvature(Float curvature) {
        return std::max(std::min(curvature, maximumCurvature), minimumCurvature);
    }

    static Float calculateCoefficient(Float sampleCount, Float curvature) {
        curvature = clampCurvature(curvature);
        return (sampleCount <= 0.0) ? 0.0 : std::exp(-std::log((1.0 + curvature) / curvature) / sampleCount);
    }

    int samplesFor(Float duration) const { return round(sampleRate_ * duration); }

    StageConfiguration configs_[numStages];

    Float sampleRate_;
};

} // namespace Render
} // namespace SF2
