// Copyright Â© 2020 Brad Howes. All rights reserved.

#pragma once

#include <cmath>
#include <limits>

#include "Types.hpp"
#include "Logger.hpp"

namespace SF2::Render::Envelope {

enum struct StageIndex {
  idle = -1,
  delay = 0,
  attack,
  hold,
  decay,
  sustain,
  release
};

inline const char* StageName(StageIndex stageIndex) {
  switch (stageIndex) {
    case StageIndex::idle: return "idle";
    case StageIndex::delay: return "delay";
    case StageIndex::attack: return "attack";
    case StageIndex::hold: return "hold";
    case StageIndex::decay: return "decay";
    case StageIndex::sustain: return "sustain";
    case StageIndex::release: return "release";
    default: throw "unknown stage value";
  }
}

class Generator;

/**
 Configuration for a single stage of an envelope.
 */
class Stage
{
public:
  inline static constexpr Float minimumCurvature = 1.0e-7f;
  inline static constexpr Float maximumCurvature = 10.0f;

  Stage() = default;

  /**
   Generate a configuration that will emit a constant value for a fixed or indefinite time.
   */
  static Stage Constant(StageIndex stageIndex, int sampleCount, Float value) {
    return Stage(stageIndex, value, 1.0, 0.0, sampleCount);
  }

  /**
   Generate a configuration for the delay stage.
   */
  static Stage Delay(int sampleCount) { return Constant(StageIndex::delay, sampleCount, 0.0); }

  /**
   Generate a configuration for the attack stage.
   */
  static Stage Attack(int sampleCount, Float curvature) {
    curvature = clampCurvature(curvature);
    Float alpha = calculateCoefficient(sampleCount, curvature);
    return Stage(StageIndex::attack, 0.0f, alpha, (1.0f + curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Generate a configuration for the delay stage.
   */
  static Stage Hold(int sampleCount) { return Constant(StageIndex::hold, sampleCount, 1.0f); }

  /**
   Generate a configuration for the decay stage.
   */
  static Stage Decay(int sampleCount, Float curvature, Float sustainLevel) {
    curvature = clampCurvature(curvature);
    Float alpha = calculateCoefficient(sampleCount, curvature);
    return Stage(StageIndex::decay, 1.0f, alpha, (sustainLevel - curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Generate a configuration for the sustain stage.
   */
  static Stage Sustain(Float level) {
    return Constant(StageIndex::sustain, std::numeric_limits<uint16_t>::max(), level);
  }

  /**
   Generate a configuration for the release stage.
   */
  static Stage Release(int sampleCount, Float curvature, Float sustainLevel) {
    curvature = clampCurvature(curvature);
    Float alpha = calculateCoefficient(sampleCount, curvature);
    return Stage(StageIndex::release, sustainLevel, alpha, (0.0f - curvature) * (1.0f - alpha), sampleCount);
  }

  /**
   Obtain the next value of a stage.

   @param last last value generated by a stage
   @returns new value
   */
  Float next(Float last) const { return std::max<Float>(std::min<Float>(last * alpha_ + beta_, 1.0), 0.0); }

  Float initial() const { return initial_; }
  Float alpha() const { return alpha_; }
  Float beta() const { return beta_; }
  int duration() const { return durationInSamples_; }
  
private:

  Stage(StageIndex stageIndex, Float initial, Float alpha, Float beta, int durationInSamples) :
  initial_{initial}, alpha_{alpha}, beta_{beta}, durationInSamples_{durationInSamples} {
    log_.info() << "Stage " << StageName(stageIndex) << " init: " << initial << " alpha: " << alpha
    << " beta: " << beta << std::endl;
  }

  static Float clampCurvature(Float curvature) {
    return std::max(std::min(curvature, maximumCurvature), minimumCurvature);
  }

  static Float calculateCoefficient(Float sampleCount, Float curvature) {
    curvature = clampCurvature(curvature);
    return (sampleCount <= 0.0f) ? 0.0f : std::exp(-std::log((1.0f + curvature) / curvature) / sampleCount);
  }

  friend class Generator;

  Float initial_{0.0};
  Float alpha_{0.0};
  Float beta_{0.0};
  int durationInSamples_{0};

  inline static Logger log_{Logger::Make("Render.Envelope", "Stage")};
};

} // namespace SF2::Render::Envelope
